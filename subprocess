import asyncio
import moteus
import moteus_pi3hat
import time
import math
import socket
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-p', "--parameters", type=float, nargs=2)
args = parser.parse_args()

length = args.parameters[0]
quantity = args.parameters[1]
drive_fwd = 2.55906 * math.pi
desired_pos = length / drive_fwd
rev = desired_pos

# Define the servo bus map. Replace this with your actual servo IDs and buses.
servo_bus_map = {
    1: [11], # Example: Servo with ID 1 is on bus 11
}

# Initialize Pi3HatRouter with the bus map
transport = moteus_pi3hat.Pi3HatRouter(
    servo_bus_map=servo_bus_map
)

# Create a Controller for the servo with ID 1, using the transport we just created
c = moteus.Controller(id=1, transport=transport)

# Create a custom query resolution for alternate registers
qr = moteus.QueryResolution()
qr._extra = {
    moteus.Register.CONTROL_POSITION: moteus.F32,
    moteus.Register.CONTROL_VELOCITY: moteus.F32,
    moteus.Register.CONTROL_TORQUE: moteus.F32,
    moteus.Register.POSITION_ERROR: moteus.F32,
    moteus.Register.VELOCITY_ERROR: moteus.F32,
    moteus.Register.TORQUE_ERROR: moteus.F32,
}

async def main():
    global length
    global quantity

    # Clear any Faults
    await c.set_stop()

    results = await c.set_position_wait_complete(
        position=desired_pos, accel_limit=8.0, watchdog_timeout=math.nan)
    await c.set_position(position=math.nan, query=True)

    # Print the results of the position and velocity query.
    print(results)

if __name__ == '__main__':
    quantity = int(quantity)
    for x in range(0, int(quantity) + 1):
        asyncio.run(main())
        print(f"CYCLE NUMBER {x}")
        desired_pos += rev
        print(desired_pos)
        time.sleep(2)
